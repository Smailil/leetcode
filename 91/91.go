package main

/*
Вы перехватили секретное сообщение, закодированное в виде строки цифр. Сообщение декодируется с помощью следующего сопоставления:
"1" -> 'A'
"2" -> 'B'
...
"25" -> 'Y'
"26" -> 'Z'

Однако при декодировании сообщения вы понимаете, что существует много разных способов декодирования сообщения, поскольку некоторые коды содержатся в других кодах («2» и «5» против «25»).
Например, «11106» можно декодировать как:

«AAJF» с группировкой (1, 1, 10, 6)
«KJF» с группировкой (11, 10, 6)
Группировка (1, 11, 06) недействительна, поскольку «06» не является допустимым кодом (действителен только «6»).
Примечание: могут существовать строки, которые невозможно декодировать.
Дана строка s, содержащая только цифры, верните количество способов ее декодирования. Если всю строку невозможно декодировать каким-либо допустимым способом, верните 0.
Тестовые случаи генерируются таким образом, чтобы ответ умещался в 32-битное целое число.

Пример 1:
Input: s = "12"
Output: 2
Объяснение:
«12» можно расшифровать как «AB» (1 2) или «L» (12).

Пример 2:
Input: s = "226"
Output: 3
Объяснение:
«226» можно декодировать как «BZ» (2 26), «VF» (22 6) или «BBF» (2 2 6).

Пример 3:
Input: s = "06"
Output: 0
Объяснение:
«06» нельзя сопоставить с «F» из-за лидирующего нуля («6» отличается от «06»). В этом случае строка не является допустимой кодировкой, поэтому верните 0.

Ограничения:
1 <= s.length <= 100
s содержит только цифры и может содержать ведущие нули.

*/

func numDecodings(s string) int {
    dp1, dp2 := 1, 0
    dp := 0 // dp[i] = dp[i+1] + ?dp[i+2]?
    for i := len(s) - 1; i >= 0; i-- {
        if s[i] == '0' {
            dp = 0
        } else {
            dp = dp1
        }
        if i+1 < len(s) && (s[i] == '1' ||
           s[i] == '2' && s[i+1] <= '6') {
            dp += dp2
        }
        dp2 = dp1
        dp1 = dp
        dp = 0
    }
    return dp1
}
