package main

/*
Существует прямоугольный остров размером m x n, который граничит как с Тихим, так и с Атлантическим океаном. 
Тихий океан касается левого и верхнего края острова, а Атлантический океан касается правого и нижнего края острова.
Остров разделен на сетку квадратных ячеек. Вам дана целочисленная матрица высот размером m x n, где heights[r][c] представляет высоту над уровнем моря ячейки в координате (r, c).
На острове выпадает много дождя, и дождевая вода может течь в соседние ячейки прямо на север, юг, восток и запад, если высота соседней ячейки меньше или равна высоте текущей ячейки. 
Вода может перетекать из любой клетки, прилегающей к океану, в океан.
Возвращает двумерный список координат сетки, где result[i] = [r_i, c_i] означает, что дождевая вода может течь из ячейки (r_i, c_i) как в Тихий, так и в Атлантический океаны.

Пример 1:
https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg
Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Пояснение: Следующие клетки могут течь в Тихий и Атлантический океаны, как показано ниже:
[0,4]: [0,4] -> Тихий океан 
 [0,4] -> Атлантический океан
[1,3]: [1,3] -> [0,3] -> Тихий океан 
 [1,3] -> [1,4] -> Атлантический океан
[1,4]: [1,4] -> [1,3] -> [0,3] -> Тихий океан 
 [1,4] -> Атлантический океан
[2,2]: [2,2] -> [1,2] -> [0,2] -> Тихий океан 
 [2,2] -> [2,3] -> [2,4] -> Атлантический океан
[3,0]: [3,0] -> Тихий океан 
 [3,0] -> [4,0] -> Атлантический океан
[3,1]: [3,1] -> [3,0] -> Тихий океан
[3,1] -> [4,1] -> Атлантический океан
[4,0]: [4,0] -> Тихий океан 
 [4,0] -> Атлантический океан
Обратите внимание, что существуют и другие возможные пути попадания этих клеток в Тихий и Атлантический океаны.

Пример 2:
Input: heights = [[1]]
Output: [[0,0]]
Пояснение: Вода может течь из единственной ячейки в Тихий и Атлантический океаны.

Ограничения:
m == heights.length
n == heights[r].length
1 <= m, n <= 200
0 <= heights[r][c] <= 10^5

*/

func pacificAtlantic(heights [][]int) [][]int {
    rows, cols := len(heights), len(heights[0])
    pac := make(map[[2]int]struct{})
    atl := make(map[[2]int]struct{})

    var dfs func(int, int, map[[2]int]struct{}, int)
    dfs = func(r, c int, visit map[[2]int]struct{}, prevHeight int) {
        if r < 0 || c < 0 ||
           r == rows || c == cols ||
           heights[r][c] < prevHeight {
            return
        }
        coord := [2]int{r, c}
		if _, ok := visit[coord]; ok {
			return 
		}

        visit[coord] = struct{}{}

        dfs(r+1, c, visit, heights[r][c])
        dfs(r-1, c, visit, heights[r][c])
        dfs(r, c+1, visit, heights[r][c])
        dfs(r, c-1, visit, heights[r][c])
    }

    for c := 0; c < cols; c++ {
        dfs(0, c, pac, heights[0][c])
        dfs(rows-1, c, atl, heights[rows-1][c])
    }

    for r := 0; r < rows; r++ {
        dfs(r, 0, pac, heights[r][0])
        dfs(r, cols-1, atl, heights[r][cols-1])
    }

    result := make([][]int, 0)
	for coord := range pac {
		if _, ok := atl[coord]; ok {
			result = append(result, []int{coord[0], coord[1]})
		}
	}

    return result
}