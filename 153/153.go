package main

/*
Предположим, что массив длины n, отсортированный в порядке возрастания, поворачивается от 1 до n раз.
Например, массив nums = [0,1,2,4,5,6,7] может выглядеть следующим образом:
[4,5,6,7,0,1,2], если его повернули 4 раза.
[0,1,2,4,5,6,7], если его повернули 7 раз.
Обратите внимание, что вращение массива [a[0], a[1], a[2], ..., a[n-1]] 1 раз приводит к созданию массива [a[n-1], a[0], a[1], a[2], ..., a[n-2]].
Даны отсортированные числа уникальных элементов повернутого массива, верните минимальный элемент этого массива.
Вы должны написать алгоритм, который работает за время O(log n).

Пример 1:
Input: nums = [3,4,5,1,2]
Output: 1
Пояснение: Исходный массив был [1,2,3,4,5] повёрнут 3 раза.

Пример 2:
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Пояснение: Исходный массив был [0,1,2,4,5,6,7] и был повернут 4 раза.

Пример 3:
Input: nums = [11,13,15,17]
Output: 11
Пояснение: Исходный массив был [11,13,15,17] и был повернут 4 раза.

Ограничения:
n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
Все целые числа nums уникальны.
nums сортируется и вращается от 1 до n раз.

*/

func findMin(nums []int) int {
    res := nums[0]
	l, r := 0, len(nums) - 1
	for l <= r {
		if nums[l] < nums[r] {
			res = min(res, nums[l])
			break
		}
		med := (l+r)/2
		res = min(res, nums[med])
		if nums[med] <= nums[l] {
			l = med + 1
		} else {
			r = med - 1
		}
	}
	return res
}
