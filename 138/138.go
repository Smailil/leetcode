package main

/*
Связный список длины n дан так, что каждый узел содержит дополнительный случайный указатель, который может указывать на любой узел в списке или на ноль.
Создайте глубокую копию списка. 
Глубокая копия должна состоять ровно из n совершенно новых узлов, где каждому новому узлу присваивается значение, равное значению соответствующего исходного узла.
И следующий, и случайный указатель новых узлов должны указывать на новые узлы в скопированном списке так, 
чтобы указатели в исходном списке и скопированном списке представляли одно и то же состояние списка. 
Ни один из указателей в новом списке не должен указывать на узлы исходного списка.
Например, если в исходном списке есть два узла X и Y, где X.random --> Y, то для соответствующих двух узлов x и y в скопированном списке x.random --> y.
Верните заголовок скопированного связанного списка.
Связанный список представляется на входе/выходе как список из n узлов. Каждый узел представлен парой [val, random_index], где:
val: целое число, представляющее Node.val
Случайный_индекс: индекс узла (диапазон от 0 до n-1), на который указывает случайный указатель, или ноль, если он не указывает ни на один узел.
Вашему коду будет присвоен только заголовок исходного связанного списка.

Пример 1:
https://assets.leetcode.com/uploads/2019/12/18/e1.png
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]

Пример 2:
https://assets.leetcode.com/uploads/2019/12/18/e2.png
Input: head = [[1,1],[2,1]]
Output: [[1,1],[2,1]]

Пример 3:
https://assets.leetcode.com/uploads/2019/12/18/e3.png
Input: head = [[3,null],[3,0],[3,null]]
Output: [[3,null],[3,0],[3,null]]

Ограничения:
0 <= n <= 1000
-10^4 <= Node.val <= 10^4
Node.random имеет значение null или указывает на какой-либо узел в связанном списке.

*/

type Node struct {
    Val int
    Next *Node
    Random *Node
}

func copyRandomList(head *Node) *Node {
    curr := head
	hash := map[*Node]*Node{nil: nil}
	for curr != nil {
		newNode := &Node{Val: curr.Val}
		hash[curr] = newNode
		curr = curr.Next
	}
	curr = head
	for curr != nil {
		newNode := hash[curr]
		newNode.Next = hash[curr.Next]
		newNode.Random = hash[curr.Random]
		curr = curr.Next
	} 
	return hash[head]
}
